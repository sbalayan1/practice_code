class
    -> is a blueprint that defines how to build an object
    -> A class both contains the instructions for creating new objects and has the ability to create those objects
    -> classes are the blueprints that defined the behavior and information ourobjects will contain and let us manufacture and instantiate new instances.
instance
    -> is a single occurrence of an obj
    -> instances refer to the individual objects produced from the class

note, unlike JS, whenever we use dot notaion in Ruby, were calling a method on an object.

Ruby Object Notation => #<Dog:0x007fc52c2cc588>
    -> is the default way that ruby communicates to you that you are dealing with an object or instance of a particular class
    -> the above tells you that the object is an instance of Dog and 0x007fc52c2cc588is its object identifier. This identifier is where the object lives inside the computer.

Instance Methods
    -> object_id: tells you the object's identifier in your computer's memory
    -> methods: returns an array of all the methods (messages) an object responds to

Instance Variables
    -> is a variable that is accessible in any instance method in a particular instance of a class
    -> instance variables lets us give our instances data. It lets us give our objects attributes/properties that let the object know their name, breed, etc.
    
    -> instance variables are bound to an instance of a class
        - this means that when we set the attribute on an instance, the value we set is associated with that particular instance.
    -> instance variables are responsible for holding information regarding an instance
    -> it has instance scope => meaning it is available to all instance methods in the class

    # example below has a setter and getter method that sets the dog_name to the LOCAL VARIABLE this_dogs_name, notice you run into an error because this_dogs_name is a local variable and cannot be accessed outside of #name=(dog_name)
    class Dog
        def name=(dog_name)
            this_dogs_name = dog_name
        end

        def name
            this_dogs_name
        end
    end

    #***** by changing this_dogs_name to an instance variable, we effectively change its scope and make the variable available to all instance methods defined within the class ******
    class Dog2
        def name=(dog_name)
            @this_dogs_name = dog_name
        end

        def name
            @this_dogs_name
        end
    end

Macros
    - metaprogramming is where we automate repetitive tasks to make our lives easier. 
    - a macro is an example of metaprogramming. Here we use the attr macros to abstract away the manual definitions of setter and getter methods.
    - attr_accessor, attr_reader, attr_writer

    -> note that when you use these methods for variables that are not instance variables, ruby auto sets these variables to nilClass and will print nothing or 0
    -> Example

    class Test
        attr_accessor :random

        def initialize
        end

        def check_random
            puts random.class #this will print NilClass
            puts random #this will print nothing
        end
    end

    test = Test.new()
    test.check_random

Initialization
    - the initialize method assigns properties to an instance upon creation or instantiation

self
    - is a special variable that points to the object that owns the current executing code.
    - self refers to the instance or class the method is being called on.
    - self is called the explicit receiver syntax. https://learning.flatironschool.com/courses/3315/pages/implicit-self?module_item_id=279245
    - note self cannot be called implicitly on setter methods

implicit receiver vs explicit receiver
    - explicit receiver syntax is where we use self to call other instance methods from a single class. For instance self.bark is explicit syntax where self receives the bark method
    - implicit receiver syntax is the same except we omit the self keyword when calling other instance methods. When ruby encounters a bare method, it will attempt to use that method and call it on self. 

    example:
    class Person
        attr_reader :name, :happiness, :hygiene
        attr_accessor :bank_account

        def initialize name
            @name = name
            @bank_account = 25
            @happiness = 8
            @hygiene = 8
        end

        # def happiness
        #     @happiness #represents the instance variable happiness
        #     #happiness #implicit receiver syntax that calls self.happiness. this calls the happiness method over and over again and creates an infinite loop
        # end

        def happiness=(value)

            # self.happiness = 0 #explicit receiver syntax calls the happiness setter method over and over again, regardless of what's passed as val
            
            #happiness = 50 here ruby views the implicit receiver as a variable assignment. Thus if you print happiness, you will get 50 because the variable happiness is 50. That being said, ruby will still attempt to apply self to the puts happiness. This results in the call and print of the happiness getter method. If you put a print in the happiness method, you'll see this method print both 50 and 8.


            #thus we need to reference the instance variable here in this setter method
            @happiness = if value > 10
                            10
                        elsif value < 0
                            0
                        else 
                            value
                        end
        end

    end

    Class Variables
        -> a class is an object itself
        -> class variables are used to store values related to the class rather than a particular instance
        -> class methods are used to implement behavior related to a class rather than a particular instance
            example
            def self.className

            end
        -> a class variable has class scope and is available to the entire class. thus we can access class variables in both isntance and class methods

        -> class constants => GENRES = ["Hip-Hop", "Pop", "Jazz"]
        -> class constants are accessible outside of a class like so Album::GENRES => ["Hip-Hop", "Pop", "Jazz"]


Other notes
    tally => used to hash the elements of an array and count occurences
        example. ['bob', 'bob', 'bob'] => {bob => 3}
    clamp => 